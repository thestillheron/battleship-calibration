# Coding Challenge - Turret Calibration

## Run Instructions

Ensure you have the following dependencies installed:

* .Net 8 SDK
* NodeJS v20

Then carry out the following instructions on a command line

1. Navigate to the frontend directory and run `npm install`
1. Then run `npm start`
1. In a separate command line window navigate to the backend directory
1. Run `dotnet test` to see the unit tests and subcutaneous tests pass
1. Run `dotnet run --project TheStillHeron.BattleshipCalibration.Api/TheStillHeron.BattleshipCalibration.Api.csproj`
1. Note that for the above command, if you are in a windows environment the slashes may be reversed
1. Note that the frontend should be running on port 3000 and the backend should be running on port 5242. They may default to other ports if you already have applications using those ports. The frontend relies on port 5242, so please make sure that's available.
1. Navigate to http://localhost:3000 (NOT https) to view the solution.

## Notes

The code in [SubcutaneousTest.cs](./TheStillHeron.BattleshipCalibration.Api.Test/TestWebApplicationFactory.cs) is my own code, but I didn't hand-write it for this code challenge. It's one of several snippets I keep on hand. I would consider it overkill for a project of this size, but because I had the snippet at hand I didn't mind spending the "effort" to implement subcutaneous testing for this project. I have trimmed it down from the full implementation to just what I need for this challenge.

## Suggested Improvements

I have used a singleton as the "storage" for this project. I would generally avoid making a service like the [CalibrationService](./TheStillHeron.BattleshipCalibration.Api/Services/CalibrationService.cs) a singleton, but for expedience in a code challenge like this I'll make an exception.

Likewise, I would not normally completely open CORS.

There is inconsistency with how the API provides error responses. If the error was generated by model binding constraints the error structure is different than when I have a business rule that fails to be met. This takes some proper architecture to address properly (error boundaries, error massaging etc.), which I would recommend in a real scenario, but not in a coding challenge.

## Assumptions

1. The number of rotations performed by a calibration run must be greater than 0.
1. When calculating the total degrees of rotation in a calibration run, we make the following assumptions:
  - We include the number of degrees required to move from the 0 degree default position of the turret to the starting position
  - We include the number of degrees required to move from the end position to the start position at the end of each rotation
  - We include the number of degrees required to move from the end position to the default 0 position at the end of the calibration run
1. For calibration runs involving more than one rotation, the turret returns to the 0 degree location at the start of each rotation.
1. For expediency, the solution does not require any security or authorisation
1. The caliber and location of the turret do not have any bearing on the result of a calibration
